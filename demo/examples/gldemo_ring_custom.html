<!DOCTYPE html>
<html lang="en">
<head>
	<title>阿凡提3D | 案例 | 戒指定制</title>
	<meta charset="utf-8">
	<link rel="icon" href="../../img/favicon.png" type="image/x-icon">
    <link rel="shortcut icon" href="../../img/favicon.png" type="image/x-icon" />
    <meta name="description" content="Codester is a free responsive Bootstrap template by Dzyngiri">
    <meta name="keywords" content="free, template, bootstrap, responsive">
    <meta name="author" content="omni360" >  
	<link rel="stylesheet" href="../../css/bootstrap.css" type="text/css" media="screen">
	<link rel="stylesheet" href="../../css/responsive.css" type="text/css" media="screen">
	<link rel="stylesheet" href="../../css/style.css" type="text/css" media="screen">
	<link rel="stylesheet" href="../../css/touchTouch.css" type="text/css" media="screen">
	<script type="text/javascript" src="../../js/jquery.js"></script>
	<script type="text/javascript" src="../../js/superfish.js"></script>
    <script type="text/javascript" src="../../js/jquery.easing.1.3.js"></script>  
    <script type="text/javascript" src="../../js/jquery.cookie.js"></script>
    <script type="text/javascript" src="../../js/touchTouch.jquery.js"></script> 

	<script type="text/javascript">if($(window).width()>1024){document.write("<"+"script src='../../js/jquery.preloader.js'></"+"script>");}	</script>
</head>

<body>
	<script src="../build/three.js"></script>
	<script src="js/utils/GeometryUtils.js"></script>

	<script src="js/shaders/ConvolutionShader.js"></script>
	<script src="js/shaders/CopyShader.js"></script>
	<script src="js/shaders/FilmShader.js"></script>
	<script src="js/shaders/FXAAShader.js"></script>

	<script src="js/postprocessing/EffectComposer.js"></script>
	<script src="js/postprocessing/RenderPass.js"></script>
	<script src="js/postprocessing/ShaderPass.js"></script>
	<script src="js/postprocessing/MaskPass.js"></script>
	<script src="js/postprocessing/BloomPass.js"></script>
	<script src="js/postprocessing/FilmPass.js"></script>

	<!-- load the font files -->

	<script src="fonts/gentilis_bold.typeface.js"></script>
	<script src="fonts/gentilis_regular.typeface.js"></script>
	<script src="fonts/optimer_bold.typeface.js"></script>
	<script src="fonts/optimer_regular.typeface.js"></script>
	<script src="fonts/helvetiker_bold.typeface.js"></script>
	<script src="fonts/helvetiker_regular.typeface.js"></script>
	<script src="fonts/droid/droid_sans_regular.typeface.js"></script>
	<script src="fonts/droid/droid_sans_bold.typeface.js"></script>
	<script src="fonts/droid/droid_serif_regular.typeface.js"></script>
	<script src="fonts/droid/droid_serif_bold.typeface.js"></script>

	<script src="js/loaders/DDSLoader.js"></script>
	<script src="js/loaders/MTLLoader.js"></script>
	<script src="js/loaders/OBJMTLLoader.js"></script>
	<script src="js/controls/TrackballControls.js"></script>
	<script src="js/loaders/BinaryLoader.js"></script>

	<script src="js/Detector.js"></script>
	<script src="js/libs/stats.min.js"></script>
	<script type="x-shader/x-vertex" id="vertexShader">

		varying vec3 vWorldPosition;

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	</script>

	<script type="x-shader/x-fragment" id="fragmentShader">

		uniform vec3 topColor;
		uniform vec3 bottomColor;
		uniform float offset;
		uniform float exponent;

		varying vec3 vWorldPosition;

		void main() {

			float h = normalize( vWorldPosition + offset ).y;
			gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h, 0.0 ), exponent ), 0.0 ) ), 1.0 );

		}

	</script>

	<header>
	      <div class="container clearfix">
	    		<div class="row">
	          	<div class="span12">
	        			<div class="navbar navbar_">
	              		<div class="container">
	            			<h1 class="brand brand_"><a href="../../index.html"><img alt="" src="../../img/logo.png"> </a></h1>
	            				<a class="btn btn-navbar btn-navbar_" data-toggle="collapse" data-target=".nav-collapse_">菜单 <span class="icon-bar"></span> </a>
	            					<div class="nav-collapse nav-collapse_  collapse">
	                 				 	<ul class="nav sf-menu">
							                <li><a href="../../index.html">主页</a></li>
							                <li class="active"><a href="../../work.html">案例</a></li>

							                <li class="sub-menu"><a href="../../process.html">解决方案</a>
					                      <ul>
						                    <li><a href="#">Process 01</a></li>
						                    <li><a href="#">Process 02</a></li>
						                    <li><a href="#">Process 03</a></li>
						                  </ul>
					                    	</li>
	  							            <li><a href="../../blog.html">博客</a></li>
							               <li><a href="../../contact.html">联系我们</a></li>
					              	 	</ul>
	               				</div>
	          			</div>
	            	</div>
	      		</div>
	        </div>
	  		</div>
	</header>
	<div class="bg-content">       
	    <div id="content">
	      	<div class="ic">
	      		
	      	</div>
		    <div class="container">
	          	<div class="row">
			        <article class="span12">
				        <h5>戒指定制</h5>
			        </article>
			        <div class="clear"></div>
			        <div class="span12" id="gldemo">
	        			<div id="info">
							type to enter new text, drag to spin the text
							<br/><span class="button" id="color">change color</span>,
								<span class="button" id="font">change font</span>,
								<span class="button" id="weight">change weight</span>,
								<span class="button" id="bevel">change bevel</span>,
								<span class="button" id="postprocessing">change postprocessing</span>,
								<a id="permalink" href="#">permalink</a>
						</div>	        	
			        </div>
			    </div>
	        </div>
	  	</div>
	</div>
	<!-- footer -->
	<footer>
	    <div class="container clearfix">
		    <ul class="list-social pull-right">
		          <li><a class="icon-1" href="#"></a></li>
		          <li><a class="icon-2" href="#"></a></li>
		          <li><a class="icon-3" href="#"></a></li>
		          <li><a class="icon-4" href="#"></a></li>
		    </ul>
		    <div class="privacy pull-left">© 2015 | 
		      <a href="http://omni360.github.io">版权所有 : 侯春雷</a> | 
		      <a href="http://twitter.github.com/bootstrap/" target="_blank">Bootstrap</a> | WebGL　Demo　by : 
		      <a href="http://omni360.github.io" target="_blank">侯春雷</a>|    
				<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1254501268'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1254501268' type='text/javascript'%3E%3C/script%3E"));</script>
			</div>
	  	</div>
	</footer>
	<script type="text/javascript" src="../../js/bootstrap.js"></script>

	<script>
		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

		var container, stats, permalink, hex, color;

		var camera, controls, scene, renderer, cameraTarget;

		var composer;
		var effectFXAA;

		var group, textMesh1, textMesh2, textGeo, material;

		var firstLetter = true;

		var text = "THREE.JS",
		// var text = "three.js",

			height = 20,
			size = 70,
			hover = 30,

			curveSegments = 4,

			bevelThickness = 2,
			bevelSize = 1.5,
			bevelSegments = 3,
			bevelEnabled = true,

			font = "optimer", // helvetiker, optimer, gentilis, droid sans, droid serif
			weight = "bold", // normal bold
			style = "normal"; // normal italic

		var mirror = true;

		var fontMap = {

			"helvetiker": 0,
			"optimer": 1,
			"gentilis": 2,
			"droid sans": 3,
			"droid serif": 4

		};

		var weightMap = {

			"normal": 0,
			"bold": 1

		};

		var reverseFontMap = {};
		var reverseWeightMap = {};

		for ( var i in fontMap ) reverseFontMap[ fontMap[i] ] = i;
		for ( var i in weightMap ) reverseWeightMap[ weightMap[i] ] = i;

		var targetRotation = 0;
		var targetRotationOnMouseDown = 0;

		var mouseX = 0, mouseY = 0;
		var cwidth = $("#gldemo").width();
		var cheight = cwidth / 1.777;

		var windowHalfX = cwidth / 2;
		var windowHalfY = cheight / 2;

		var postprocessing = { enabled : false };
		var glow = 0.9;

		init();
		animate();

		function capitalize( txt ) {

			return txt.substring( 0, 1 ).toUpperCase() + txt.substring( 1 );

		}

		function decimalToHex( d ) {

			var hex = Number( d ).toString( 16 );
			hex = "000000".substr( 0, 6 - hex.length ) + hex;
			return hex.toUpperCase();

		}

		function init() {
			permalink = document.getElementById( "permalink" );
			// container = document.createElement( 'div' );
			// document.body.appendChild( container );

			// camera = new THREE.PerspectiveCamera( 45, cwidth / cheight, 1, 10000 );
			// camera.position.z = 250;
			// camera.lookAt( 0,0,0 );
			camera = new THREE.PerspectiveCamera( 30, cwidth / cheight, 1, 15000 );
			camera.position.set( 0, 500, 900 );
			// carmera = new THREE.OrthographicCamera( 2000, 2000, 2000, 2000, 1, 15000 );
			// carmera.position.set(0,1500,0);
			cameraTarget = new THREE.Vector3( 0, 150, 0 );


			// controls = new THREE.TrackballControls( camera );

			// controls.rotateSpeed = 1.0;
			// controls.zoomSpeed = 1.2;
			// controls.panSpeed = 0.8;

			// controls.noZoom = false;
			// controls.noPan = false;

			// controls.staticMoving = true;
			// controls.dynamicDampingFactor = 0.15;

			// controls.keys = [ 65, 83, 68 ];

			// controls.addEventListener( 'change', render );

			// scene

			scene = new THREE.Scene();
			scene.fog = new THREE.Fog( 0xffffff, 300, 2000 );
			scene.fog.color.setHSL( 0.6, 0, 1 );


			// LIGHTS

			hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
			hemiLight.color.setHSL( 0.6, 1, 0.6 );
			hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
			hemiLight.position.set( 0, 500, 0 );
			scene.add( hemiLight );

			//

			// dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
			// dirLight.color.setHSL( 0.1, 1, 0.95 );
			// dirLight.position.set( -1, 1.75, 1 );
			// dirLight.position.multiplyScalar( 50 );
			// scene.add( dirLight );

			// dirLight.castShadow = true;

			// dirLight.shadowMapWidth = 2048;
			// dirLight.shadowMapHeight = 2048;

			// var d = 50;

			// dirLight.shadowCameraLeft = -d;
			// dirLight.shadowCameraRight = d;
			// dirLight.shadowCameraTop = d;
			// dirLight.shadowCameraBottom = -d;

			// dirLight.shadowCameraFar = 3500;
			// dirLight.shadowBias = -0.0001;
			// dirLight.shadowDarkness = 0.35;
			//dirLight.shadowCameraVisible = true;
			var dirLight = new THREE.DirectionalLight( 0xffffff, 0.125 );
			dirLight.position.set( 0, 0, 1 ).normalize();
			scene.add( dirLight );

			var pointLight = new THREE.PointLight( 0xffffff, 1.5 );
			pointLight.position.set( 0, 100, 90 );
			scene.add( pointLight );

			// GROUND

			var groundGeo = new THREE.PlaneBufferGeometry( 10000, 10000 );
			var groundMat = new THREE.MeshPhongMaterial( { ambient: 0xffffff, color: 0xffffff, specular: 0x050505,opacity: 0.5, transparent: true } );
			groundMat.color.setHSL( 0.095, 1, 0.75 );

			var ground = new THREE.Mesh( groundGeo, groundMat );
			ground.rotation.x = -Math.PI/2;
			ground.position.y = 100;
			scene.add( ground );

			ground.receiveShadow = true;

			// SKYDOME

			var vertexShader = document.getElementById( 'vertexShader' ).textContent;
			var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
			var uniforms = {
				topColor: 	 { type: "c", value: new THREE.Color( 0x0077ff ) },
				bottomColor: { type: "c", value: new THREE.Color( 0xffffff ) },
				offset:		 { type: "f", value: 100 },
				exponent:	 { type: "f", value: 0.6 }
			}
			uniforms.topColor.value.copy( hemiLight.color );

			scene.fog.color.copy( uniforms.bottomColor.value );

			var skyGeo = new THREE.SphereGeometry( 2000, 32, 15 );
			var skyMat = new THREE.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide } );

			var sky = new THREE.Mesh( skyGeo, skyMat );
			scene.add( sky );

			//text = capitalize( font ) + " " + capitalize( weight );
			//text = "abcdefghijklmnopqrstuvwxyz0123456789";
			//text = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

			// Get text from hash

			var hash = document.location.hash.substr( 1 );

			if ( hash.length !== 0 ) {

				var colorhash  = hash.substring( 0, 6 );
				var fonthash   = hash.substring( 6, 7 );
				var weighthash = hash.substring( 7, 8 );
				var pphash 	   = hash.substring( 8, 9 );
				var bevelhash  = hash.substring( 9, 10 );
				var texthash   = hash.substring( 10 );

				hex = colorhash;
				pointLight.color.setHex( parseInt( colorhash, 16 ) );

				font = reverseFontMap[ parseInt( fonthash ) ];
				weight = reverseWeightMap[ parseInt( weighthash ) ];

				postprocessing.enabled = parseInt( pphash );
				bevelEnabled = parseInt( bevelhash );

				text = decodeURI( texthash );

				updatePermalink();

			} else {

				pointLight.color.setHSL( Math.random(), 1, 0.5 );
				hex = decimalToHex( pointLight.color.getHex() );

			}

			material = new THREE.MeshFaceMaterial( [
				new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.FlatShading } ),//, wireframe:true } ), // front
				new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.SmoothShading } ) // side
			] );

			group = new THREE.Group();
			group.position.y = 100;

			scene.add( group );

			var map = THREE.ImageUtils.loadTexture( 'textures/UV_Grid_Sm.jpg' );
			map.wrapS = map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 16;

			var ringMaterial = new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: map, side: THREE.DoubleSide, wireframe: true } );

			var ring = new THREE.Mesh( new THREE.RingGeometry( 280 + hover, 300 + hover, 180, 5, 0, Math.PI * 1.5 ), ringMaterial );
			ring.rotation.x = Math.PI / 2;
			ring.position.y = 0;
			group.add( ring );

			createText();
			drawArcText( text, 300, 0, Math.PI * 2);

			// var plane = new THREE.Mesh(
			// 	new THREE.PlaneBufferGeometry( 10000, 10000 ),
			// 	new THREE.MeshBasicMaterial( { color: 0xffffff, opacity: 0.5, transparent: true } )
			// );
			// plane.position.y = 100;
			// plane.rotation.x = - Math.PI / 2;
			// scene.add( plane );

			//

			renderer = new THREE.WebGLRenderer({ antialias:true }); //, alpha: true });
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( cwidth, cheight );
			$("#gldemo").append( renderer.domElement );

			// document.addEventListener( 'mousemove', onDocumentMouseMove, false );

				// STATS

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				//container.appendChild( stats.domElement );

			// EVENTS

			document.addEventListener( 'mousedown', onDocumentMouseDown, false );
			document.addEventListener( 'touchstart', onDocumentTouchStart, false );
			document.addEventListener( 'touchmove', onDocumentTouchMove, false );
			document.addEventListener( 'keypress', onDocumentKeyPress, false );
			document.addEventListener( 'keydown', onDocumentKeyDown, false );

			document.getElementById( "color" ).addEventListener( 'click', function() {

				pointLight.color.setHSL( Math.random(), 1, 0.5 );
				hex = decimalToHex( pointLight.color.getHex() );

				updatePermalink();

			}, false );

			document.getElementById( "font" ).addEventListener( 'click', function() {

				if ( font == "helvetiker" ) {

					font = "optimer";

				} else if ( font == "optimer" ) {

					font = "gentilis";

				} else if ( font == "gentilis" ) {

					font = "droid sans";

				} else if ( font == "droid sans" ) {

					font = "droid serif";

				} else {

					font = "helvetiker";

				}

				refreshText();

			}, false );

			document.getElementById( "weight" ).addEventListener( 'click', function() {

				if ( weight == "bold" ) {

					weight = "normal";

				} else {

					weight = "bold";

				}

				refreshText();

			}, false );

			document.getElementById( "bevel" ).addEventListener( 'click', function() {

				bevelEnabled = !bevelEnabled;

				refreshText();

			}, false );

			document.getElementById( "postprocessing" ).addEventListener( 'click', function() {

				postprocessing.enabled = !postprocessing.enabled;
				updatePermalink();

			}, false );


			// POSTPROCESSING

			renderer.autoClear = false;

			var renderModel = new THREE.RenderPass( scene, camera );
			var effectBloom = new THREE.BloomPass( 0.25 );
			var effectFilm = new THREE.FilmPass( 0.5, 0.125, 2048, false );

			effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );

			var width = cwidth || 2;
			var height = cheight || 2;

			effectFXAA.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );

			effectFilm.renderToScreen = true;

			composer = new THREE.EffectComposer( renderer );

			composer.addPass( renderModel );
			composer.addPass( effectFXAA );
			composer.addPass( effectBloom );
			composer.addPass( effectFilm );

			//
			window.addEventListener( 'resize', onWindowResize, false );

			//
			render();

		}

		function onWindowResize() {

			windowHalfX = cwidth / 2;
			windowHalfY = cheight / 2;

			camera.aspect = cwidth / cheight;
			camera.updateProjectionMatrix();

			renderer.setSize( cwidth, cheight );

			composer.reset();

			effectFXAA.uniforms[ 'resolution' ].value.set( 1 / cwidth, 1 / cheight );

		}

		//

		function boolToNum( b ) {

			return b ? 1 : 0;

		}

		function updatePermalink() {

			var link = hex + fontMap[ font ] + weightMap[ weight ] + boolToNum( postprocessing.enabled ) + boolToNum( bevelEnabled ) + "#" + encodeURI( text );

			permalink.href = "#" + link;
			window.location.hash = link;

		}

		function onDocumentKeyDown( event ) {

			if ( firstLetter ) {

				firstLetter = false;
				text = "";

			}

			var keyCode = event.keyCode;

			// backspace

			if ( keyCode == 8 ) {

				event.preventDefault();

				text = text.substring( 0, text.length - 1 );
				refreshText();

				return false;

			}

		}

		function onDocumentKeyPress( event ) {

			var keyCode = event.which;

			// backspace

			if ( keyCode == 8 ) {

				event.preventDefault();

			} else {

				var ch = String.fromCharCode( keyCode );
				text += ch;

				refreshText();

			}

		}

		function createText() {

			textGeo = new THREE.TextGeometry( text, {

				size: size,
				height: height,
				curveSegments: curveSegments,

				font: font,
				weight: weight,
				style: style,

				bevelThickness: bevelThickness,
				bevelSize: bevelSize,
				bevelEnabled: bevelEnabled,

				material: 0,
				extrudeMaterial: 1

			});

			textGeo.computeBoundingBox();
			textGeo.computeVertexNormals();

			// "fix" side normals by removing z-component of normals for side faces
			// (this doesn't work well for beveled geometry as then we lose nice curvature around z-axis)

			if ( ! bevelEnabled ) {

				var triangleAreaHeuristics = 0.1 * ( height * size );

				for ( var i = 0; i < textGeo.faces.length; i ++ ) {

					var face = textGeo.faces[ i ];

					if ( face.materialIndex == 1 ) {

						for ( var j = 0; j < face.vertexNormals.length; j ++ ) {

							face.vertexNormals[ j ].z = 0;
							face.vertexNormals[ j ].normalize();

						}

						var va = textGeo.vertices[ face.a ];
						var vb = textGeo.vertices[ face.b ];
						var vc = textGeo.vertices[ face.c ];

						var s = THREE.GeometryUtils.triangleArea( va, vb, vc );

						if ( s > triangleAreaHeuristics ) {

							for ( var j = 0; j < face.vertexNormals.length; j ++ ) {

								face.vertexNormals[ j ].copy( face.normal );

							}

						}

					}

				}

			}

			var centerOffset = -0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

			textMesh1 = new THREE.Mesh( textGeo, material );

			textMesh1.position.x = centerOffset;
			textMesh1.position.y = hover;
			textMesh1.position.z = 0;

			textMesh1.rotation.x = 0;
			textMesh1.rotation.y = Math.PI * 2;

			group.add( textMesh1 );
			var bounding = new THREE.BoxHelper(textMesh1);

			scene.add(bounding);
			console.log(bounding);

			if ( mirror ) {

				textMesh2 = new THREE.Mesh( textGeo, material );

				textMesh2.position.x = centerOffset;
				textMesh2.position.y = -hover;
				textMesh2.position.z = height;

				textMesh2.rotation.x = Math.PI;
				textMesh2.rotation.y = Math.PI * 2;

				group.add( textMesh2 );

			}

		}

		function drawArcText(textString, radiusArg, thetaStartArg, thetaLengthArg) {

			var radius = radiusArg !== undefined ? radiusArg : 300;
			var thetaStart = thetaStartArg !== undefined ? thetaStartArg : 0;
			var thetaLength = thetaLengthArg !== undefined ? thetaLengthArg : Math.PI * 2;

			var chars = String(textString).split(''),
				length = chars.length;

			var textCharsGeo = [];

			for (var i =0; i < length; i++) {

				var charLocation = thetaStart + i / (length + 1) * thetaLength;
				var charAngle = Math.PI / 2 - i / length * thetaLength;
				var charAngleMirrored = Math.PI /2 + i / length * thetaLength;

				var charGeo = new THREE.TextGeometry( chars[i], {

				size: size,
				height: height,
				curveSegments: curveSegments,

				font: font,
				weight: weight,
				style: style,

				bevelThickness: bevelThickness,
				bevelSize: bevelSize,
				bevelEnabled: bevelEnabled,

				material: 0,
				extrudeMaterial: 1

				} );

				charGeo.computeBoundingBox();
				charGeo.computeVertexNormals();

				if (! bevelEnabled) {

					var triangleAreaHeuristics = 0.1 * (height * size);

					for (var i = 0; i < chargeo.faces.length; i++) {
						
						var face = chargeo.faces[i];

						if(face.materialIndex == 1) {

							for (var j = 0; j < face.vertexNormals.length; j++) {

								face.vertexNormals[j].z = 0;
								face.vertexNormals[j].normalize();

							};

							var va = charGeo.vertices[face.a];
							var vb = charGeo.vertices[face.b];
							var vc = charGeo.vertices[face.c];

							var s = THREE.GeometryUtils.triangleArea( va, vb, vc );

							if( s > triangleAreaHeuristics ) {

								for (var j = 0; j < face.vertexNormals.length; j++) {

									face.vertexNormals[j].copy( face.normal );

								};
							}

						}
					};
				};

				var centerOffset = -0.5 * ( charGeo.boundingBox.max.x - charGeo.boundingBox.min.x );

				charGeo.center.x = radius * Math.cos(charLocation);
				charGeo.center.y = 0;
				charGeo.center.z = radius * Math.sin(charLocation);

				textMesh1 = new THREE.Mesh( charGeo, material );

				// textMesh1.lookAt(textMesh1.position);

				textMesh1.position.x = radius * Math.cos(charLocation);
				textMesh1.position.y = 0;
				textMesh1.position.z = radius * Math.sin(charLocation);

				textMesh1.rotation.x = 0;
				textMesh1.rotation.y = charAngle;

				group.add( textMesh1 );

				// var w = charGeo.boundingBox.max.x - charGeo.boundingBox.min.x;
				// var h = charGeo.boundingBox.max.y - charGeo.boundingBox.min.y;
				// var d = charGeo.boundingBox.max.z - charGeo.boundingBox.min.z;

				var bounding = new THREE.BoxHelper(textMesh1);

				scene.add(bounding);
				console.log(bounding);
				// console.log("char: " + chars[i]);
				// console.log("w: " + w);
				// console.log("h: " + h);
				// console.log("d: " + d);

				// var box =  new THREE.BoxGeometry( w, h, d);
				// box.computeBoundingBox();
				// var cubematerial = new THREE.MeshBasicMaterial( { color : 0x000000, wireframe : true} );
				// var cube = new THREE.Mesh(box, cubematerial);
				// cube.position.copy(textMesh1.position );
				// cube.rotation.copy(textMesh1.rotation );
				// cube.position.x += w / 2;
				// cube.position.y += h / 2;
				// cube.position.z += d / 2;
				// group.add(cube);

				// console.log("tx: " + textMesh1.position.x);
				// console.log("ty: " + textMesh1.position.y);
				// console.log("tz: " + textMesh1.position.z);

				// console.log("x: " + cube.position.x);
				// console.log("y: " + cube.position.y);
				// console.log("z: " + cube.position.z);
				// console.log(box.center());
				// console.log(charGeo.center());
				// textMesh1.rotation.z = Math.PI / 6; 

				if ( mirror ) {

					textMesh2 = textMesh1.clone();
					// textMesh2 = new THREE.Mesh( charGeo, material );

					// textMesh2.position.x = radius * Math.cos(charLocation);
					textMesh2.position.y = -hover;
					// textMesh2.position.z = radius * Math.sin(charLocation);

					textMesh2.rotation.x = Math.PI;
					textMesh2.rotation.y = charAngleMirrored ;

					// group.add( textMesh2 );

				}

			};

		}

		function refreshText() {

			updatePermalink();

			group.remove( textMesh1 );
			if ( mirror ) group.remove( textMesh2 );

			if ( !text ) return;

			createText();
			drawArcText( text,300, 0, Math.PI * 2 );

		}

		function onDocumentMouseDown( event ) {

			event.preventDefault();

			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			document.addEventListener( 'mouseup', onDocumentMouseUp, false );
			document.addEventListener( 'mouseout', onDocumentMouseOut, false );

			mouseXOnMouseDown = event.clientX - windowHalfX;
			targetRotationOnMouseDown = targetRotation;

		}

		function onDocumentMouseMove( event ) {

			mouseX = event.clientX - windowHalfX;

			targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;

		}

		function onDocumentMouseUp( event ) {

			document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
			document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
			document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

		}

		function onDocumentMouseOut( event ) {

			document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
			document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
			document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

		}

		function onDocumentTouchStart( event ) {

			if ( event.touches.length == 1 ) {

				event.preventDefault();

				mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
				targetRotationOnMouseDown = targetRotation;

			}

		}

		function onDocumentTouchMove( event ) {

			if ( event.touches.length == 1 ) {

				event.preventDefault();

				mouseX = event.touches[ 0 ].pageX - windowHalfX;
				targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;

			}

		}

		//

		function animate() {

			requestAnimationFrame( animate );

			render();
			stats.update();

		}

		function render() {

			group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;

			camera.lookAt( cameraTarget );

			renderer.clear();

			if ( postprocessing.enabled ) {

				composer.render( 0.05 );

			} else {

				renderer.render( scene, camera );

			}

		}
		// function onWindowResize() {

		// 	windowHalfX = cwidth / 2;
		// 	windowHalfY = cheight / 2;

		// 	camera.aspect = cwidth / cheight;
		// 	camera.updateProjectionMatrix();

		// 	renderer.setSize( cwidth, cheight );

		// 	controls.handleResize();
		// 	render();

		// }


		// function animate() {

		// 	requestAnimationFrame( animate );
		// 	controls.update();
		// 	render();

		// }

		// function render() {

		// 	renderer.render( scene, camera );

		// }

	</script>
</body>
</html>