// Generated by CoffeeScript 1.7.1
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  describe("Keypress:", function() {
    var SHIFT, convert_readable_key_to_keycode, event_for_key, listener, on_keydown, on_keyup, press_key;
    SHIFT = false;
    listener = null;
    beforeEach(function() {
      return listener = new window.keypress.Listener();
    });
    convert_readable_key_to_keycode = function(keyname) {
      var keycode, name, _ref;
      _ref = window._keycode_dictionary;
      for (keycode in _ref) {
        name = _ref[keycode];
        if (name === keyname) {
          return keycode;
        }
      }
    };
    event_for_key = function(key) {
      var event, key_code;
      event = {};
      event.preventDefault = function() {};
      event.shiftKey = SHIFT;
      spyOn(event, "preventDefault");
      key_code = convert_readable_key_to_keycode(key);
      event.keyCode = key_code;
      return event;
    };
    on_keydown = function(key) {
      var event, _ref;
      if (key === "shift") {
        SHIFT = true;
      }
      event = event_for_key(key);
      event.metaKey = __indexOf.call(listener._keys_down, "meta") >= 0 || (_ref = listener.get_meta_key(), __indexOf.call(listener._keys_down, _ref) >= 0);
      listener._receive_input(event, true);
      listener._bug_catcher(event);
      return event;
    };
    on_keyup = function(key) {
      var event;
      if (key === "shift") {
        SHIFT = false;
      }
      event = event_for_key(key);
      listener._receive_input(event, false);
      return event;
    };
    press_key = function(key) {
      on_keydown(key);
      return on_keyup(key);
    };
    describe("A simple single key basic combo", function() {
      afterEach(function() {
        return listener.reset();
      });
      it("just works", function() {
        var foo;
        foo = 0;
        listener.simple_combo(["a"], function() {
          return foo = 1;
        });
        press_key("a");
        return expect(foo).toEqual(1);
      });
      it("defaults to not preventing default", function() {
        var event;
        listener.simple_combo("a", null);
        event = on_keydown("a");
        on_keyup("a");
        return expect(event.preventDefault).not.toHaveBeenCalled();
      });
      it("will prevent default keydown if we have an on_keydown function that doesn't return true", function() {
        var event;
        listener.simple_combo("a", function() {});
        event = on_keydown("a");
        on_keyup("a");
        return expect(event.preventDefault).toHaveBeenCalled();
      });
      it("will not prevent default keydown if we have an on_keydown function that does return true", function() {
        var event;
        listener.simple_combo("a", function() {
          return true;
        });
        event = on_keydown("a");
        on_keyup("a");
        return expect(event.preventDefault).not.toHaveBeenCalled();
      });
      return it("will only prevent for the final event by default if we don't return true", function() {
        var event;
        listener.simple_combo("a b", function() {});
        event = on_keydown("a");
        expect(event.preventDefault).not.toHaveBeenCalled();
        event = on_keydown("b");
        expect(event.preventDefault).toHaveBeenCalled();
        on_keyup("a");
        return on_keyup("b");
      });
    });
    describe("Shift key helpers", function() {
      var key_handler;
      key_handler = null;
      beforeEach(function() {
        return key_handler = jasmine.createSpy();
      });
      afterEach(function() {
        return listener.reset();
      });
      it("evaluates keys as shifted to match combos", function() {
        listener.simple_combo("!", key_handler);
        on_keydown("shift");
        on_keydown("1");
        expect(key_handler).toHaveBeenCalled();
        on_keyup("shift");
        return on_keyup("1");
      });
      return it("still fires the correct keyup even if you let off shift first", function() {
        listener.register_combo({
          keys: "a !",
          on_keydown: key_handler,
          on_keyup: key_handler
        });
        on_keydown("shift");
        on_keydown("a");
        on_keydown("1");
        expect(key_handler).toHaveBeenCalled();
        on_keyup("shift");
        expect(key_handler.calls.length).toEqual(1);
        on_keyup("1");
        on_keyup("a");
        return expect(key_handler.calls.length).toEqual(2);
      });
    });
    describe("Bug catcher", function() {
      var key_handler;
      key_handler = null;
      beforeEach(function() {
        return key_handler = jasmine.createSpy();
      });
      afterEach(function() {
        return listener.reset();
      });
      return it("forces keyup on keys when cmd is held down", function() {
        listener.register_combo({
          keys: "cmd v",
          on_keydown: key_handler,
          on_keyup: key_handler
        });
        on_keydown("cmd");
        on_keydown("v");
        expect(key_handler.calls.length).toEqual(2);
        on_keyup("v");
        return on_keyup("cmd");
      });
    });
    describe("Keyup events with no relevant keydown event", function() {
      var key_handler;
      key_handler = null;
      beforeEach(function() {
        return key_handler = jasmine.createSpy();
      });
      afterEach(function() {
        return listener.reset();
      });
      return it("won't fire the keyup when we alt-tab/cmd-tab in", function() {
        listener.register_combo({
          keys: "cmd",
          on_keyup: key_handler
        });
        listener.register_combo({
          keys: "alt",
          on_keyup: key_handler
        });
        on_keyup("cmd");
        expect(key_handler).not.toHaveBeenCalled();
        on_keyup("alt");
        return expect(key_handler).not.toHaveBeenCalled();
      });
    });
    describe("Explicit combo options", function() {
      var key_handler;
      key_handler = null;
      beforeEach(function() {
        return key_handler = jasmine.createSpy();
      });
      afterEach(function() {
        return listener.reset();
      });
      describe("keys", function() {
        it("can take an array", function() {
          listener.register_combo({
            keys: ["a"],
            on_keydown: key_handler
          });
          press_key("a");
          return expect(key_handler).toHaveBeenCalled();
        });
        return it("can take a string", function() {
          listener.register_combo({
            keys: "a",
            on_keydown: key_handler
          });
          press_key("a");
          return expect(key_handler).toHaveBeenCalled();
        });
      });
      describe("on_keydown", function() {
        it("receives the event and combo count as arguments", function() {
          var down_event, received_event;
          received_event = null;
          listener.simple_combo("a", function(event, count) {
            expect(count).toEqual(0);
            return received_event = event;
          });
          down_event = on_keydown("a");
          on_keyup("a");
          return expect(received_event).toEqual(down_event);
        });
        it("only fires when all of the keys have been pressed", function() {
          listener.simple_combo("a b c", key_handler);
          on_keydown("a");
          expect(key_handler).not.toHaveBeenCalled();
          on_keydown("b");
          expect(key_handler).not.toHaveBeenCalled();
          on_keydown("c");
          expect(key_handler).toHaveBeenCalled();
          on_keyup("a");
          on_keyup("b");
          return on_keyup("c");
        });
        it("will fire each time the final key is pressed", function() {
          var foo;
          foo = 0;
          listener.simple_combo("a b", function() {
            return foo += 1;
          });
          on_keydown("a");
          on_keydown("b");
          on_keyup("b");
          on_keydown("b");
          expect(foo).toEqual(2);
          on_keyup("b");
          return on_keyup("a");
        });
        return it("properly receives is_autorepeat", function() {
          var did_repeat;
          did_repeat = false;
          listener.simple_combo("a", function(event, count, is_autorepeat) {
            return did_repeat = is_autorepeat;
          });
          on_keydown("a");
          expect(did_repeat).toBe(false);
          on_keydown("a");
          expect(did_repeat).toBe(true);
          on_keydown("a");
          expect(did_repeat).toBe(true);
          return on_keyup("a");
        });
      });
      describe("on_keyup", function() {
        it("fires properly", function() {
          listener.register_combo({
            keys: "a",
            on_keyup: key_handler
          });
          press_key("a");
          return expect(key_handler).toHaveBeenCalled();
        });
        it("receives the event as its argument", function() {
          var received_event, up_event;
          received_event = null;
          listener.register_combo({
            keys: "a",
            on_keyup: function(event) {
              return received_event = event;
            }
          });
          on_keydown("a");
          up_event = on_keyup("a");
          return expect(received_event).toEqual(up_event);
        });
        return it("fires only after all keys are down and the first has been released", function() {
          listener.register_combo({
            keys: "a b c",
            on_keyup: key_handler
          });
          on_keydown("a");
          on_keydown("b");
          on_keydown("c");
          expect(key_handler).not.toHaveBeenCalled();
          on_keyup("b");
          expect(key_handler).toHaveBeenCalled();
          on_keyup("c");
          expect(key_handler.calls.length).toEqual(1);
          on_keyup("a");
          return expect(key_handler.calls.length).toEqual(1);
        });
      });
      describe("on_release", function() {
        return it("only fires after all of the keys have been released", function() {
          listener.register_combo({
            keys: "a b c",
            on_release: key_handler
          });
          on_keydown("a");
          on_keydown("b");
          on_keydown("c");
          expect(key_handler).not.toHaveBeenCalled();
          on_keyup("b");
          expect(key_handler).not.toHaveBeenCalled();
          on_keyup("c");
          expect(key_handler).not.toHaveBeenCalled();
          on_keyup("a");
          return expect(key_handler).toHaveBeenCalled();
        });
      });
      describe("this keyword", function() {
        it("defaults to window", function() {
          listener.simple_combo("a", function() {
            return expect(this).toEqual(window);
          });
          return press_key("a");
        });
        return it("can be set to any arbitrary scope", function() {
          var my_scope;
          my_scope = {};
          listener.register_combo({
            keys: "a",
            "this": my_scope,
            on_keydown: function() {
              return expect(this).toEqual(my_scope);
            }
          });
          return press_key("a");
        });
      });
      describe("prevent_default", function() {
        it("manual: only prevents on the key that activated the handler", function() {
          var a_down_event, a_up_event, b_down_event, b_up_event, c_down_event, c_up_event;
          listener.register_combo({
            keys: "a b c",
            on_keydown: function(event) {
              return event.preventDefault();
            },
            on_keyup: function(event) {
              return event.preventDefault();
            },
            on_release: function(event) {
              return event.preventDefault();
            }
          });
          a_down_event = on_keydown("a");
          expect(a_down_event.preventDefault).not.toHaveBeenCalled();
          b_down_event = on_keydown("b");
          expect(b_down_event.preventDefault).not.toHaveBeenCalled();
          c_down_event = on_keydown("c");
          expect(c_down_event.preventDefault).toHaveBeenCalled();
          a_up_event = on_keyup("a");
          expect(a_up_event.preventDefault).toHaveBeenCalled();
          b_up_event = on_keyup("b");
          expect(b_up_event.preventDefault).not.toHaveBeenCalled();
          c_up_event = on_keyup("c");
          return expect(c_up_event.preventDefault).toHaveBeenCalled();
        });
        it("return any non-true value: only prevents the key that activated the handler", function() {
          var a_down_event, a_up_event, b_down_event, b_up_event, c_down_event, c_up_event;
          listener.register_combo({
            keys: "a b c",
            on_keydown: function(event) {
              return false;
            },
            on_keyup: function(event) {
              return false;
            },
            on_release: function(event) {
              return false;
            }
          });
          a_down_event = on_keydown("a");
          expect(a_down_event.preventDefault).not.toHaveBeenCalled();
          b_down_event = on_keydown("b");
          expect(b_down_event.preventDefault).not.toHaveBeenCalled();
          c_down_event = on_keydown("c");
          expect(c_down_event.preventDefault).toHaveBeenCalled();
          a_up_event = on_keyup("a");
          expect(a_up_event.preventDefault).toHaveBeenCalled();
          b_up_event = on_keyup("b");
          expect(b_up_event.preventDefault).not.toHaveBeenCalled();
          c_up_event = on_keyup("c");
          return expect(c_up_event.preventDefault).toHaveBeenCalled();
        });
        return it("property: prevents on all events related and only those related", function() {
          var a_down_event, a_up_event, b_down_event, b_up_event, c_down_event, c_up_event, x_down_event, x_up_event;
          listener.register_combo({
            keys: "a b c",
            prevent_default: true,
            on_keydown: function() {},
            on_keyup: function() {},
            on_release: function() {}
          });
          a_down_event = on_keydown("a");
          expect(a_down_event.preventDefault).toHaveBeenCalled();
          b_down_event = on_keydown("b");
          expect(b_down_event.preventDefault).toHaveBeenCalled();
          x_down_event = on_keydown("x");
          expect(x_down_event.preventDefault).not.toHaveBeenCalled();
          c_down_event = on_keydown("c");
          expect(c_down_event.preventDefault).toHaveBeenCalled();
          a_up_event = on_keyup("a");
          x_up_event = on_keyup("x");
          b_up_event = on_keyup("b");
          c_up_event = on_keyup("c");
          expect(a_up_event.preventDefault).toHaveBeenCalled();
          expect(x_up_event.preventDefault).not.toHaveBeenCalled();
          expect(b_up_event.preventDefault).toHaveBeenCalled();
          return expect(c_up_event.preventDefault).toHaveBeenCalled();
        });
      });
      describe("prevent_repeat", function() {
        it("allows multiple firings of the keydown event by default", function() {
          listener.simple_combo("a", key_handler);
          on_keydown("a");
          on_keydown("a");
          expect(key_handler.calls.length).toEqual(2);
          return on_keyup("a");
        });
        return it("only fires the first time it is pressed down when true", function() {
          listener.register_combo({
            keys: "a",
            on_keydown: key_handler,
            prevent_repeat: true
          });
          on_keydown("a");
          on_keydown("a");
          expect(key_handler.calls.length).toEqual(1);
          return on_keyup("a");
        });
      });
      describe("is_unordered", function() {
        it("forces the order described by default", function() {
          listener.register_combo({
            keys: "a b",
            on_keydown: key_handler
          });
          on_keydown("b");
          on_keydown("a");
          on_keyup("b");
          on_keyup("a");
          expect(key_handler).not.toHaveBeenCalled();
          on_keydown("a");
          on_keydown("b");
          on_keyup("a");
          on_keyup("b");
          return expect(key_handler).toHaveBeenCalled();
        });
        return it("allows a user to press the keys in any order when is_unordered", function() {
          listener.register_combo({
            keys: "a b",
            on_keydown: key_handler,
            is_unordered: true
          });
          on_keydown("b");
          on_keydown("a");
          on_keyup("b");
          on_keyup("a");
          return expect(key_handler).toHaveBeenCalled();
        });
      });
      describe("is_counting", function() {
        it("calls the keydown handler with the count", function() {
          var last_count;
          last_count = 0;
          listener.register_combo({
            keys: "tab x space",
            is_counting: true,
            on_keydown: function(event, count) {
              return last_count = count;
            }
          });
          on_keydown("tab");
          on_keydown("x");
          on_keydown("space");
          expect(last_count).toEqual(1);
          on_keyup("space");
          on_keydown("space");
          expect(last_count).toEqual(2);
          on_keyup("space");
          on_keyup("x");
          return on_keyup("tab");
        });
        it("does not increment count on keyup if we have keydown handler", function() {
          var last_count;
          last_count = 0;
          listener.register_combo({
            keys: "tab space",
            is_counting: true,
            on_keydown: function(event, count) {
              return last_count = count;
            },
            on_keyup: function(event, count) {
              return last_count = count;
            }
          });
          on_keydown("tab");
          on_keydown("space");
          expect(last_count).toEqual(1);
          on_keyup("space");
          expect(last_count).toEqual(1);
          return on_keyup("tab");
        });
        return it("resets the count even if the combo gets dropped", function() {
          var last_count;
          last_count = 0;
          listener.register_combo({
            keys: "tab space",
            is_counting: true,
            on_keydown: function(event, count) {
              return last_count = count;
            }
          });
          listener.register_combo({
            keys: "tab space a",
            on_keydown: key_handler
          });
          on_keydown("tab");
          on_keydown("space");
          expect(last_count).toEqual(1);
          on_keydown("a");
          expect(key_handler).toHaveBeenCalled();
          on_keyup("a");
          on_keyup("space");
          on_keyup("tab");
          on_keydown("tab");
          on_keydown("space");
          expect(last_count).toEqual(1);
          on_keyup("space");
          return on_keyup("tab");
        });
      });
      describe("is_sequence", function() {
        it("properly registers a sequence", function() {
          listener.register_combo({
            keys: "h i",
            is_sequence: true,
            on_keydown: key_handler
          });
          press_key("h");
          press_key("i");
          return expect(key_handler).toHaveBeenCalled();
        });
        it("only calls the keydown handler after the last key has been pressed", function() {
          listener.register_combo({
            keys: "h i",
            is_sequence: true,
            on_keydown: key_handler
          });
          press_key("h");
          expect(key_handler).not.toHaveBeenCalled();
          press_key("i");
          return expect(key_handler).toHaveBeenCalled();
        });
        it("only calls the keyup handler after the last key has been released", function() {
          listener.register_combo({
            keys: "h i",
            is_sequence: true,
            on_keyup: key_handler
          });
          press_key("h");
          expect(key_handler).not.toHaveBeenCalled();
          press_key("i");
          return expect(key_handler).toHaveBeenCalled();
        });
        it("completely ignores the on_release block", function() {
          listener.register_combo({
            keys: "h i",
            is_sequence: true,
            on_release: key_handler
          });
          press_key("h");
          expect(key_handler).not.toHaveBeenCalled();
          press_key("i");
          return expect(key_handler).not.toHaveBeenCalled();
        });
        it("works with the prevent_default property", function() {
          var h_keydown, i_keydown, t_keydown;
          listener.register_combo({
            keys: "h i t",
            is_sequence: true,
            prevent_default: true,
            on_keydown: key_handler
          });
          h_keydown = on_keydown("h");
          on_keyup("h");
          i_keydown = on_keydown("i");
          on_keyup("i");
          t_keydown = on_keydown("t");
          on_keyup("t");
          expect(key_handler).toHaveBeenCalled();
          expect(h_keydown.preventDefault).toHaveBeenCalled();
          expect(i_keydown.preventDefault).toHaveBeenCalled();
          return expect(t_keydown.preventDefault).toHaveBeenCalled();
        });
        return it("will trigger overlapping sequences", function() {
          listener.register_combo({
            keys: "h i",
            is_sequence: true,
            on_keydown: key_handler
          });
          listener.register_combo({
            keys: "h i t",
            is_sequence: true,
            on_keydown: key_handler
          });
          press_key("h");
          press_key("i");
          press_key("t");
          return expect(key_handler.calls.length).toEqual(2);
        });
      });
      describe("is_exclusive", function() {
        it("will fire all combos by default", function() {
          listener.register_combo({
            keys: "a b",
            on_keydown: key_handler
          });
          listener.register_combo({
            keys: "a b c",
            on_keydown: key_handler
          });
          on_keydown("a");
          on_keydown("b");
          on_keydown("c");
          expect(key_handler.calls.length).toEqual(2);
          on_keyup("a");
          on_keyup("b");
          return on_keyup("c");
        });
        it("will not fire keydown for a less specific combo", function() {
          var fired;
          fired = null;
          listener.register_combo({
            keys: "a b",
            is_exclusive: true,
            on_keydown: function() {
              fired = "smaller";
              return key_handler();
            }
          });
          listener.register_combo({
            keys: "a b c",
            is_exclusive: true,
            on_keydown: function() {
              fired = "bigger";
              return key_handler();
            }
          });
          on_keydown("a");
          on_keydown("b");
          on_keydown("c");
          expect(key_handler.calls.length).toEqual(1);
          expect(fired).toEqual("bigger");
          on_keyup("a");
          on_keyup("b");
          return on_keyup("c");
        });
        it("will not fire keyup for a less specific combo", function() {
          var fired;
          fired = null;
          listener.register_combo({
            keys: "a b",
            is_exclusive: true,
            on_keyup: function() {
              fired = "smaller";
              return key_handler();
            }
          });
          listener.register_combo({
            keys: "a b c",
            is_exclusive: true,
            on_keyup: function() {
              fired = "bigger";
              return key_handler();
            }
          });
          on_keydown("a");
          on_keydown("b");
          on_keydown("c");
          on_keyup("c");
          on_keyup("b");
          on_keyup("a");
          expect(key_handler.calls.length).toEqual(1);
          return expect(fired).toEqual("bigger");
        });
        return it("will fire a less specific combo if the bigger did NOT fire", function() {
          var fired;
          fired = null;
          listener.register_combo({
            keys: "a b",
            is_exclusive: true,
            on_keyup: function() {
              fired = "smaller";
              return key_handler();
            }
          });
          listener.register_combo({
            keys: "a b c",
            is_exclusive: true,
            on_keyup: function() {
              fired = "bigger";
              return key_handler();
            }
          });
          on_keydown("a");
          on_keydown("b");
          on_keyup("b");
          on_keyup("a");
          expect(key_handler.calls.length).toEqual(1);
          return expect(fired).toEqual("smaller");
        });
      });
      return describe("is_solitary", function() {
        it("will not fire the combo if additional keys are pressed", function() {
          listener.register_combo({
            keys: "a b",
            is_solitary: true,
            on_keydown: key_handler,
            on_keyup: key_handler,
            on_release: key_handler
          });
          on_keydown("a");
          on_keydown("x");
          on_keydown("b");
          on_keyup("a");
          on_keyup("x");
          on_keyup("b");
          return expect(key_handler).not.toHaveBeenCalled();
        });
        return it("will not fire up if down was not fired", function() {
          listener.register_combo({
            keys: "a b",
            is_solitary: true,
            on_keydown: key_handler,
            on_keyup: key_handler,
            on_release: key_handler
          });
          on_keydown("a");
          on_keydown("x");
          on_keydown("b");
          on_keyup("x");
          on_keyup("a");
          on_keyup("b");
          return expect(key_handler).not.toHaveBeenCalled();
        });
      });
    });
    return describe("Keyboard Shortcuts", function() {
      afterEach(function() {
        return listener.reset();
      });
      return describe("Escape", function() {
        return it("works with 'escape' and 'esc'", function() {
          var count, handler;
          count = 0;
          handler = function() {
            return count += 1;
          };
          listener.register_combo({
            keys: "escape",
            on_keydown: handler
          });
          on_keydown("esc");
          expect(count).toEqual(1);
          listener.unregister_combo("esc");
          expect(listener.get_registered_combos().length).toEqual(0);
          listener.register_combo({
            keys: "esc",
            on_keydown: handler
          });
          on_keydown("esc");
          return expect(count).toEqual(2);
        });
      });
    });
  });

  describe("Keypress Functional components:", function() {
    var listener;
    listener = null;
    beforeEach(function() {
      return listener = new window.keypress.Listener();
    });
    afterEach(function() {
      return listener.reset();
    });
    describe("_is_array_in_array_sorted", function() {
      it("case 1", function() {
        var result;
        result = window._is_array_in_array_sorted(["a", "b"], ["a", "b", "c"]);
        return expect(result).toBe(true);
      });
      it("case 2", function() {
        var result;
        result = window._is_array_in_array_sorted(["a", "b", "c"], ["a", "b"]);
        return expect(result).toBe(false);
      });
      it("case 3", function() {
        var result;
        result = window._is_array_in_array_sorted(["a", "b"], ["a", "x", "b"]);
        return expect(result).toBe(true);
      });
      return it("case 4", function() {
        var result;
        result = window._is_array_in_array_sorted(["b", "a"], ["a", "x", "b"]);
        return expect(result).toBe(false);
      });
    });
    return describe("_fuzzy_match_combo_arrays", function() {
      it("properly matches even with something else in the array", function() {
        var foo;
        listener.register_combo({
          keys: "a b"
        });
        foo = 0;
        listener._fuzzy_match_combo_arrays(["a", "x", "b"], function() {
          return foo += 1;
        });
        return expect(foo).toEqual(1);
      });
      it("won't match a sorted combo that isn't in the same order", function() {
        var foo;
        listener.register_combo({
          keys: "a b",
          is_unordered: false
        });
        foo = 0;
        listener._fuzzy_match_combo_arrays(["b", "x", "a"], function() {
          return foo += 1;
        });
        return expect(foo).toEqual(0);
      });
      return it("will match a sorted combo that is in the correct order", function() {
        var foo;
        listener.register_combo({
          keys: "a b",
          is_unordered: false
        });
        foo = 0;
        listener._fuzzy_match_combo_arrays(["a", "x", "b"], function() {
          return foo += 1;
        });
        return expect(foo).toEqual(1);
      });
    });
  });

  describe("APIs behave as expected:", function() {
    var listener;
    listener = null;
    beforeEach(function() {
      return listener = new window.keypress.Listener();
    });
    afterEach(function() {
      return listener.reset();
    });
    return describe("unregister_combo", function() {
      it("unregisters string", function() {
        var count;
        listener.register_combo({
          keys: "shift s"
        });
        count = listener.get_registered_combos().length;
        expect(count).toEqual(1);
        listener.unregister_combo("shift s");
        count = listener.get_registered_combos().length;
        return expect(count).toEqual(0);
      });
      it("unregisters array", function() {
        var count;
        listener.register_combo({
          keys: "shift s"
        });
        count = listener.get_registered_combos().length;
        expect(count).toEqual(1);
        listener.unregister_combo(["shift", "s"]);
        count = listener.get_registered_combos().length;
        return expect(count).toEqual(0);
      });
      it("unregisters array out of order", function() {
        var count;
        listener.register_combo({
          keys: "shift s",
          is_unordered: true
        });
        count = listener.get_registered_combos().length;
        expect(count).toEqual(1);
        listener.unregister_combo(["s", "shift"]);
        count = listener.get_registered_combos().length;
        return expect(count).toEqual(0);
      });
      return it("does not unregister if the combo is ordered and not unregistered with the same ordering", function() {
        var count;
        listener.register_combo({
          keys: "shift s",
          is_unordered: false
        });
        count = listener.get_registered_combos().length;
        expect(count).toEqual(1);
        listener.unregister_combo(["s", "shift"]);
        count = listener.get_registered_combos().length;
        return expect(count).toEqual(1);
      });
    });
  });

}).call(this);
